// 1. В чем разница между null и undefined?
// null - это намеренное отсутствие объекта, присвоенное пустое значение
// undefined - указывает, что переменная была объявлена, но не инициализирована, т.е., имеет неопределенное отсутствие значения

// 2. Почему вывод в консоль obj.someprop.x приводит к ошибке?

// const obj = {};
// console.log(obj.someprop.x);
// obj - пустой объект, который не имеет свойства someprop, в результате console.log(obj.someprop) вернёт undefined.
// Пытаясь обратиться к obj.someprop.x, мы получим ошибку, так как obj.someprop = undefined, а undefined не является объектом.
// Следовательно, нельзя получить свойство объекта x у undefined, будет ошибка типа TypeError.

// 3. Как проверить, является ли значение массивом?

// метод 1. использование метода Array.isArray()

// пример
const arr = [1, 2, 3];
console.log(Array.isArray(arr)); // выведет true

// метод 2. использование instanceof

// пример
console.log(arr instanceof Array); // выведет true

// 4. Проверить, является ли целое число квадратом, не используя математические функции.

const funcsqrt = (a) => {
  // цикл for для перебора каждой цифры от 1 до числа, которое нужно проверить
  for (let i = 1; i <= a; i++) {
    const numbersqrt = a / i; // деление вводимого числа на i, чтобы найти число - корень
    if (numbersqrt * numbersqrt == a) { // проверка, если при умножении числа на себя получаем исходное число, то оно является квадратом
      return `${numbersqrt} - это корень из числа ${a}`; // вывод корня и числа, которое проверяем
    }
  }
  return 'число не является квадратом'; // если проверка не пройдена, возвращаем этот ответ
};

console.log(funcsqrt(49)); // 7 - это корень из числа 49

const funcsqrt2 = (number) => {
  return !(number ** 0.5 % 1); // проверяем, является ли квадратный корень целым числом
};
console.log('это квадрат? ' + funcsqrt2(49)); // это квадрат? true

// 5. Написать функцию, которая принимает строку и возвращает true, если строка является палиндромом, и false, если это не так.
// Пробелы, знаки препинания не учитываем, регистр символов игнорируем.

// вариант 1
const str = 'racecar';
const reversestr = str.split('').reverse().join(''); //с помощью метода split() превращаем сроку в массив, метод reverse переворачивает его, а метод join снова соединяет обратно в строку
console.log(str === reversestr ? true : false); // если изначаотная строка равна перевернутой, то выводит true, или false, в случае, если они не равны

// вариант 2
function palindrome(str) {
  const strpalindrom = str.toLowerCase(); // игнорируем регистр символов, меняем на строчные буквы, не заглавные

  // используем два указателя: один с начала строки, другой с конца
  let left = 0;
  let right = strpalindrom.length - 1;

  // пока указатели не встретятся
  while (left < right) {
    // если символы не совпадают, это не палиндром
    if (strpalindrom[left] !== strpalindrom[right]) {
      return false; // возвращаем false, так как они не равны 
    }
    left++; //чтобы перейти на следующую букву, прибавляем символ у левой части
    right--;//чтобы перейти на следующую букву, убавляем символ у правой части
  }
  return true; // если все символы совпали, строка палиндром
}

console.log(palindrome('racecar')); // true

// 6. Написать функцию, которая возвращает n-ую запись в последовательности Фибоначчи, где n — это число, передаваемое в функцию.

function fibonacci(n) {
  // проверяем, если n меньше 0, то нет корректного числа Фибоначчи
  if (n < 0) {
    return 'введите положительное число';
  }
  // первые два числа последовательности Фибоначчи: 0 и 1
  if (n === 0) return 0;
  if (n === 1) return 1;

  // начальные значения для первых двух чисел последовательности
  let prev = 0;
  let curr = 1;

  // вычисляем n-е число Фибоначчи с помощью цикла
  for (let i = 2; i <= n; i++) {
    let next = prev + curr; // следующее число — это сумма двух предыдущих
    prev = curr; // сдвигаем предыдущее значение
    curr = next; // текущее становится следующим
  }

  return curr; // возвращаем n-е число
}

console.log(fibonacci(3)); // 2


//7. Попробуйте проанализировать, что делает следующий код.

// массив с числами
const nums = [0, 39, 28, 34, 1, 3, 6, 8, 4, 72, 7];

// цикл для перебора элементов массива
nums.forEach(num => {
  // вызываем setTimeout с задержкой, равной значению num
  setTimeout(() => {
    console.log(num); // выводим число
  }, num); // num определяет задержку
});

// ответ :  вывод числа консоль будет зависеть от задержки, тоесть числа num, которое мы вводим, так как setTimeout - асинхронная функция и позволяет javascript работать в многопоточном режиме,
// чем меньше число num, тем быстрее задача попадет в очередь задач и будет выполнена

